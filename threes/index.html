<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - 3DS loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			} 
		</style>
	</head>

	<body>
	 

		<script src="three.js"></script>
		<script src="TrackballControls.js"></script>
		<script src="TDSLoader.js"></script>

		<script>
			var container, controls,auto_remote = 1;
			var camera, scene, renderer;
			init();
			animate();
			myCameraTween(camera, 1, 3600,1000) 
			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.z = 2;
				controls = new THREE.TrackballControls( camera );
				scene = new THREE.Scene();
				scene.add( new THREE.HemisphereLight() );
				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 0, 2 );
				scene.add( directionalLight );
				var loader = new THREE.TextureLoader();
				var texture = loader.load( 'color.jpg' );
				var normal = loader.load( 'normal.jpg' );
				var loader = new THREE.TDSLoader( );
				loader.load( 'portalgun.3ds', function ( object ) {
					object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							child.material.map = texture;
							child.material.normalMap = normal;
						}
					} );
					scene.add( object );
				});
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', resize, false );
			}
			function resize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				controls.update();
				renderer.render( scene, camera );
				requestAnimationFrame( animate );
			}
			function log_(w){
				console.log(w);
			}
			document.addEventListener("click",function(){
				log_("auto_remote:"+auto_remote); 
				auto_remote=auto_remote?0:0;
			});
			/*
			 *camera:相机
			 *angle：旋转角度
			 *segs:分段，即圆弧对应的路径分为几段
			 *during：动画执行的时间
			*/
			function myCameraTween(camera, angle, segs, during) {

				var x = camera.position.x;
				var y = camera.position.y;
				var z = camera.position.z;


				var endPosArray = new Array();

				var perAngle = angle / segs;

				for (var i = 1 ; i <= segs ; i++) {
					var endPos = { "x": z * Math.sin(i * perAngle) + x * Math.cos(i * perAngle), "y": y, "z": z * Math.cos(i * perAngle) - x * Math.sin(i * perAngle) };

					endPosArray.push(endPos);
				} 
				var flag = 0;
				setInterval(function () {
					log_("auto_remote:"+auto_remote);
					 if (flag == segs) {
						flag = 0;
					}
					if(auto_remote == 1){
						camera.position.x = endPosArray[flag].x;
						camera.position.y = endPosArray[flag].y;
						camera.position.z = endPosArray[flag].z; 
						flag++;
					}  
				}, during / segs);
			}
		</script>

	</body>
</html>